m_program->addShaderFromSourceCode(QOpenGLShader::Vertex,
"attribute highp vec4 posAttr;\n"
"attribute lowp vec4 colAttr;\n"
"varying lowp vec4 col;\n"
"\n"
"uniform highp mat4 matrix;\n"
"uniform highp mat4 prevMatrix;\n"
"\n"
"void main() {\n"
"   vec4 finalColor = colAttr;\n"
"\n"
"   // ------------------------\n"
"   // 💠 1. Posun (translace)\n"
"   // ------------------------\n"
"   // Čtvrtý sloupec matice obsahuje posun objektu (Tx, Ty, Tz)\n"
"   bool isTranslating = distance(matrix[3], prevMatrix[3]) > 0.0001;\n"
"\n"
"   // ------------------------\n"
"   // 🔁 2. Rotace (změna v orientaci)\n"
"   // ------------------------\n"
"   // Porovnáváme horní 3x3 část matice (rotace, možná i scale)\n"
"   bool isRotating = false;\n"
"   for (int i = 0; i < 3; ++i) {\n"
"       for (int j = 0; j < 3; ++j) {\n"
"           if (abs(matrix[i][j] - prevMatrix[i][j]) > 0.0001) {\n"
"               isRotating = true;\n"
"           }\n"
"       }\n"
"   }\n"
"\n"
"   // ------------------------\n"
"   // 🔍 3. Škálování (scale)\n"
"   // ------------------------\n"
"   // Vypočítáme délky osových vektorů z horní 3x3 části\n"
"   float scaleX = length(vec3(matrix[0].x, matrix[0].y, matrix[0].z));\n"
"   float scaleY = length(vec3(matrix[1].x, matrix[1].y, matrix[1].z));\n"
"   float scaleZ = length(vec3(matrix[2].x, matrix[2].y, matrix[2].z));\n"
"   bool isScaled = abs(scaleX - 1.0) > 0.01 || abs(scaleY - 1.0) > 0.01 || abs(scaleZ - 1.0) > 0.01;\n"
"\n"
"   // ------------------------\n"
"   // 🔧 4. Zkosení (shear)\n"
"   // ------------------------\n"
"   // Pokud osy nejsou kolmé, je ve scéně shear (např. X a Y nejsou kolmé)\n"
"   float shearXY = dot(normalize(matrix[0].xyz), normalize(matrix[1].xyz));\n"
"   bool isSheared = abs(shearXY) > 0.01;\n"
"\n"
"   // ------------------------\n"
"   // 🔃 5. Převrácení / zrcadlení (determinant < 0)\n"
"   // ------------------------\n"
"   // Jestli je matice „převrácená“ (např. zrcadlená nebo obrácená)\n"
"   float det = \n"
"       matrix[0][0] * (matrix[1][1] * matrix[2][2] - matrix[1][2] * matrix[2][1]) -\n"
"       matrix[0][1] * (matrix[1][0] * matrix[2][2] - matrix[1][2] * matrix[2][0]) +\n"
"       matrix[0][2] * (matrix[1][0] * matrix[2][1] - matrix[1][1] * matrix[2][0]);\n"
"   bool isMirrored = det < 0.0;\n"
"\n"
"   // ------------------------\n"
"   // 🎨 Barva podle transformace\n"
"   // ------------------------\n"
"   if (isTranslating) {\n"
"       // Ztmavíme barvu o 30 %\n"
"       finalColor.rgb *= 0.7;\n"
"   }\n"
"\n"
"   if (isRotating) {\n"
"       // Smícháme s modrou barvou 50 % průhlednost\n"
"       finalColor = mix(finalColor, vec4(0.0, 0.0, 1.0, 0.5), 0.5);\n"
"   }\n"
"\n"
"   if (isScaled) {\n"
"       // Zvýrazníme zelenou složku\n"
"       finalColor.g += 0.3;\n"
"   }\n"
"\n"
"   if (isSheared) {\n"
"       // Zbarvíme do fialova\n"
"       finalColor.rgb = mix(finalColor.rgb, vec3(0.5, 0.0, 0.5), 0.5);\n"
"   }\n"
"\n"
"   if (isMirrored) {\n"
"       // Invertujeme barvu (negativ)\n"
"       finalColor.rgb = vec3(1.0) - finalColor.rgb;\n"
"   }\n"
"\n"
"   col = finalColor;\n"
"   gl_Position = matrix * posAttr;\n"
"}\n");

m_program->addShaderFromSourceCode(QOpenGLShader::Fragment,
"varying lowp vec4 col;\n"
"\n"
"void main() {\n"
"    gl_FragColor = col;\n"
"}\n");